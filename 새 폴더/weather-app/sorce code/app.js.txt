/* =========================
   Rain No - app.js (FULL)
   ========================= */

/** ✅ OpenWeather API Key (필수) */
const OPENWEATHER_API_KEY = "YOUR_OPENWEATHER_KEY";

/** ✅ 디자인 기준 사이즈 (CSS :root --W/--H와 맞춰줘) */
const DESIGN_W = 1920;
const DESIGN_H = 1080;

/** ✅ (CSS 변수용) scale */
let curSx = 1;
let curSy = 1;

/** ✅ Kakao Map */
let map = null;
let geocoder = null;
let places = null;
let polyline = null;

/** ✅ 상태 */
let lastRightClickLatLng = null;
let pickingMode = null; // "start" | "end" | null
let startLatLng = null;
let endLatLng = null;
let startMarker = null;
let endMarker = null;

const FAVORITES_KEY = "rainno_favorites_v1";
let favorites = [];

/** ✅ 마커 관리 */
const searchMarkers = [];
const favoriteMarkers = new Map(); // id -> marker

/** ✅ 날씨 요청 중복/경쟁 방지 */
const weatherCache = new Map(); // key(lat,lng) -> { ts, data }
const weatherControllers = new Map(); // key(lat,lng) -> AbortController

/** ✅ 컨텍스트 메뉴 중복 호출 방지 */
let ignoreDomContextUntil = 0;

/** ✅ DOM */
const dom = {
  canvas: null,
  mapEl: null,
  ctxMenu: null,
  ctxAddFavBtn: null,

  searchInput: null,
  searchBtn: null,

  tabSearch: null,
  tabRoute: null,
  paneSearch: null,
  paneRoute: null,

  routeStartInput: null,
  routeEndInput: null,
  pickStartBtn: null,
  pickEndBtn: null,
  routeBtn: null,
  routeResetBtn: null,
  routeInfo: null,

  weatherIcon: null,
  umbrellaIcon: null,

  favoriteList: null,
};

function asset(path) {
  return encodeURI(path);
}

/* -------------------------
   Scale (CSS variables)
-------------------------- */
function updateCanvasScale() {
  const sx = window.innerWidth / DESIGN_W;
  const sy = window.innerHeight / DESIGN_H;

  curSx = sx;
  curSy = sy;

  document.documentElement.style.setProperty("--sx", String(sx));
  document.documentElement.style.setProperty("--sy", String(sy));
}

/* -------------------------
   ✅ #map 요소의 "실제 transform 스케일" 계산
   - getBoundingClientRect() : 화면에 보이는(변환된) 크기
   - offsetWidth/offsetHeight : 레이아웃(변환 전) 크기
-------------------------- */
function getMapElementScale() {
  if (!dom.mapEl) return { sx: 1, sy: 1, rect: null };

  const rect = dom.mapEl.getBoundingClientRect();

  const baseW = dom.mapEl.offsetWidth || dom.mapEl.clientWidth || rect.width || 1;
  const baseH = dom.mapEl.offsetHeight || dom.mapEl.clientHeight || rect.height || 1;

  const sx = rect.width / baseW;
  const sy = rect.height / baseH;

  return {
    sx: Number.isFinite(sx) && sx > 0 ? sx : 1,
    sy: Number.isFinite(sy) && sy > 0 ? sy : 1,
    rect,
  };
}

/* -------------------------
   ✅ client 좌표 -> map container 좌표(px)
   (transform 보정은 #map 실제 스케일로!)
-------------------------- */
function clientToMapContainerPoint(clientX, clientY) {
  const { sx, sy, rect } = getMapElementScale();
  if (!rect) return { x: 0, y: 0 };

  const xScaled = clientX - rect.left;
  const yScaled = clientY - rect.top;

  // containerPoint는 "변환 전" 좌표계이므로 나눠줘야 함
  const x = xScaled / sx;
  const y = yScaled / sy;

  return { x, y };
}

/* -------------------------
   ✅ client 좌표 -> LatLng
-------------------------- */
function clientToLatLng(clientX, clientY) {
  if (!map || !dom.mapEl) return null;
  const proj = map.getProjection?.();
  if (!proj) return null;

  const { x, y } = clientToMapContainerPoint(clientX, clientY);
  return proj.coordsFromContainerPoint(new kakao.maps.Point(x, y));
}

/* -------------------------
   ✅ (Kakao mouseEvent용) 위경도 얻기
   - domEvent 있으면 client 기반
   - 없으면 point 기반 (주의: point는 containerPoint)
-------------------------- */
function getFixedLatLng(mouseEvent) {
  if (!map || !mouseEvent) return null;

  if (mouseEvent.domEvent) {
    return (
      clientToLatLng(mouseEvent.domEvent.clientX, mouseEvent.domEvent.clientY) ||
      mouseEvent.latLng ||
      null
    );
  }

  if (mouseEvent.point) {
    const proj = map.getProjection?.();
    if (proj) return proj.coordsFromContainerPoint(mouseEvent.point);
  }

  return mouseEvent.latLng || null;
}

/* -------------------------
   ✅ 컨텍스트 메뉴 DOM 보장 + "무조건 body로 이동"
-------------------------- */
function ensureContextMenuDom() {
  let menu = document.getElementById("map-context-menu");

  if (!menu) {
    menu = document.createElement("div");
    menu.id = "map-context-menu";
    document.body.appendChild(menu);
  } else {
    if (menu.parentElement !== document.body) document.body.appendChild(menu);
  }

  menu.style.position = "fixed";
  menu.style.display = "none";
  menu.style.zIndex = "999999";
  menu.style.minWidth = "170px";
  menu.style.padding = "10px";
  menu.style.background = "#fff";
  menu.style.borderRadius = "12px";
  menu.style.boxShadow = "0 8px 25px rgba(0,0,0,0.25)";
  menu.style.pointerEvents = "auto";

  if (!menu.querySelector("#ctx-add-favorite")) {
    menu.innerHTML = `
      <button id="ctx-add-favorite" type="button"
        style="
          width:100%;
          padding:8px 10px;
          border:none;
          border-radius:10px;
          background:#ffcc00;
          font-weight:800;
          cursor:pointer;
        ">
        ⭐ 즐겨찾기 추가
      </button>
    `;
  }

  dom.ctxMenu = menu;
  dom.ctxAddFavBtn = menu.querySelector("#ctx-add-favorite");
}

/* -------------------------
   Favorites storage
-------------------------- */
function loadFavorites() {
  try {
    const raw = localStorage.getItem(FAVORITES_KEY);
    favorites = raw ? JSON.parse(raw) : [];
    if (!Array.isArray(favorites)) favorites = [];
  } catch {
    favorites = [];
  }
}

function saveFavorites() {
  localStorage.setItem(FAVORITES_KEY, JSON.stringify(favorites));
}

/* -------------------------
   Weather mapping
-------------------------- */
function getWeatherIconIndexFromOpenWeather(weatherId, iconStr) {
  if (weatherId >= 200 && weatherId < 300) return 6;
  if (weatherId >= 300 && weatherId < 400) return 5;
  if (weatherId >= 500 && weatherId < 600) return 5;
  if (weatherId >= 600 && weatherId < 700) return 1;
  if (weatherId >= 700 && weatherId < 800) return 4;
  if (weatherId === 800) return 0;
  if (weatherId >= 801 && weatherId <= 803) return 3;
  if (weatherId === 804) return 4;
  if (typeof iconStr === "string" && iconStr.includes("n")) return 3;
  return 3;
}

function isUmbrellaNeededFromOpenWeather(weatherId) {
  return (
    (weatherId >= 200 && weatherId < 300) ||
    (weatherId >= 300 && weatherId < 400) ||
    (weatherId >= 500 && weatherId < 700)
  );
}

/* -------------------------
   Weather fetch (current)
-------------------------- */
async function fetchWeather(lat, lng) {
  const key = `${lat.toFixed(5)},${lng.toFixed(5)}`;
  const now = Date.now();

  const cached = weatherCache.get(key);
  if (cached && now - cached.ts < 2 * 60 * 1000) return cached.data;

  const prev = weatherControllers.get(key);
  if (prev) prev.abort();

  const controller = new AbortController();
  weatherControllers.set(key, controller);

  if (!OPENWEATHER_API_KEY || OPENWEATHER_API_KEY === "YOUR_OPENWEATHER_KEY") {
    const fallback = { weatherId: 800, icon: "01d", temp: null };
    weatherCache.set(key, { ts: now, data: fallback });
    return fallback;
  }

  const url =
    `https://api.openweathermap.org/data/2.5/weather` +
    `?lat=${encodeURIComponent(lat)}` +
    `&lon=${encodeURIComponent(lng)}` +
    `&appid=${encodeURIComponent(OPENWEATHER_API_KEY)}` +
    `&units=metric` +
    `&lang=kr`;

  const res = await fetch(url, { signal: controller.signal });
  if (!res.ok) throw new Error("Weather fetch failed");

  const json = await res.json();
  const weatherId = json?.weather?.[0]?.id ?? 800;
  const icon = json?.weather?.[0]?.icon ?? "01d";
  const temp = typeof json?.main?.temp === "number" ? json.main.temp : null;

  const data = { weatherId, icon, temp };
  weatherCache.set(key, { ts: now, data });
  return data;
}

/* -------------------------
   UI update (top cards)
-------------------------- */
async function updateTopCardsByLatLng(lat, lng) {
  try {
    const w = await fetchWeather(lat, lng);
    const idx = getWeatherIconIndexFromOpenWeather(w.weatherId, w.icon);
    const umbrellaNeeded = isUmbrellaNeededFromOpenWeather(w.weatherId);

    if (dom.weatherIcon) dom.weatherIcon.src = asset(`weather icon/${idx}.png`);
    if (dom.umbrellaIcon) dom.umbrellaIcon.src = asset(`umbrella icon/${umbrellaNeeded ? 1 : 0}.png`);
  } catch {
    if (dom.weatherIcon) dom.weatherIcon.src = asset(`weather icon/0.png`);
    if (dom.umbrellaIcon) dom.umbrellaIcon.src = asset(`umbrella icon/0.png`);
  }
}

/* -------------------------
   Favorite list render
-------------------------- */
function clearFavoriteList() {
  if (!dom.favoriteList) return;
  dom.favoriteList.innerHTML = "";
}

function makeFavoriteRow(fav, weatherIdx, umbrellaNeeded) {
  const li = document.createElement("li");
  li.className = "favorite-item";
  li.dataset.id = fav.id;

  const main = document.createElement("div");
  main.className = "favorite-main";

  const title = document.createElement("span");
  title.className = "favorite-title";
  title.textContent = fav.name || "즐겨찾기";

  const addr = document.createElement("span");
  addr.className = "favorite-address";
  addr.textContent = fav.roadAddress || fav.jibunAddress || "주소 없음";

  main.appendChild(title);
  main.appendChild(addr);

  const right = document.createElement("div");
  right.className = "favorite-right";

  const wImg = document.createElement("img");
  wImg.className = "favorite-weather-icon";
  wImg.alt = "weather";
  wImg.src = asset(`weather icon/${weatherIdx}.png`);

  const uImg = document.createElement("img");
  uImg.className = "favorite-weather-icon";
  uImg.alt = "umbrella";
  uImg.src = asset(`umbrella icon/${umbrellaNeeded ? 1 : 0}.png`);

  const actions = document.createElement("div");
  actions.className = "favorite-actions";

  const editBtn = document.createElement("button");
  editBtn.className = "favorite-edit";
  editBtn.type = "button";
  editBtn.textContent = "이름 수정";

  const removeBtn = document.createElement("button");
  removeBtn.className = "favorite-remove";
  removeBtn.type = "button";
  removeBtn.textContent = "삭제";

  actions.appendChild(editBtn);
  actions.appendChild(removeBtn);

  right.appendChild(wImg);
  right.appendChild(uImg);
  right.appendChild(actions);

  li.appendChild(main);
  li.appendChild(right);

  main.addEventListener("click", () => {
    if (!map) return;
    const latlng = new kakao.maps.LatLng(fav.lat, fav.lng);
    map.panTo(latlng);
    updateTopCardsByLatLng(fav.lat, fav.lng).catch(() => {});
  });

  editBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    const next = prompt("새 이름을 입력하세요", fav.name || "");
    if (typeof next === "string" && next.trim()) {
      fav.name = next.trim();
      saveFavorites();
      renderFavorites().catch(() => {});
    }
  });

  removeBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    if (!confirm("이 즐겨찾기를 삭제할까요?")) return;
    favorites = favorites.filter((x) => x.id !== fav.id);
    saveFavorites();
    removeFavoriteMarker(fav.id);
    renderFavorites().catch(() => {});
  });

  return li;
}

async function renderFavorites() {
  clearFavoriteList();
  syncFavoriteMarkers();

  if (!dom.favoriteList) return;

  const skeleton = document.createElement("li");
  skeleton.className = "favorite-item";
  skeleton.innerHTML = `<div class="favorite-main"><span class="favorite-title">불러오는 중...</span></div>`;
  dom.favoriteList.appendChild(skeleton);

  const rows = [];
  for (const fav of favorites) {
    try {
      const w = await fetchWeather(fav.lat, fav.lng);
      const wIdx = getWeatherIconIndexFromOpenWeather(w.weatherId, w.icon);
      const umbrellaNeeded = isUmbrellaNeededFromOpenWeather(w.weatherId);
      rows.push(makeFavoriteRow(fav, wIdx, umbrellaNeeded));
    } catch {
      rows.push(makeFavoriteRow(fav, 3, false));
    }
  }

  clearFavoriteList();
  rows.forEach((r) => dom.favoriteList.appendChild(r));
}

/* -------------------------
   Map markers (favorites)
-------------------------- */
function favoriteMarkerImage() {
  try {
    return new kakao.maps.MarkerImage(
      asset("need/1.png"),
      new kakao.maps.Size(34, 34),
      { offset: new kakao.maps.Point(17, 34) }
    );
  } catch {
    return null;
  }
}

function syncFavoriteMarkers() {
  if (!map) return;

  const ids = new Set(favorites.map((f) => f.id));
  for (const [id, marker] of favoriteMarkers.entries()) {
    if (!ids.has(id)) {
      marker.setMap(null);
      favoriteMarkers.delete(id);
    }
  }

  const img = favoriteMarkerImage();
  for (const fav of favorites) {
    let mk = favoriteMarkers.get(fav.id);
    const pos = new kakao.maps.LatLng(fav.lat, fav.lng);

    if (!mk) {
      mk = new kakao.maps.Marker({
        position: pos,
        image: img || undefined,
        clickable: true,
      });
      mk.setMap(map);
      favoriteMarkers.set(fav.id, mk);

      kakao.maps.event.addListener(mk, "click", () => {
        map.panTo(pos);
        updateTopCardsByLatLng(fav.lat, fav.lng).catch(() => {});
      });
    } else {
      mk.setPosition(pos);
    }
  }
}

function removeFavoriteMarker(id) {
  const mk = favoriteMarkers.get(id);
  if (mk) mk.setMap(null);
  favoriteMarkers.delete(id);
}

/* -------------------------
   Search markers
-------------------------- */
function clearSearchMarkers() {
  while (searchMarkers.length) {
    const m = searchMarkers.pop();
    m.setMap(null);
  }
}

function addSearchMarker(latlng) {
  const marker = new kakao.maps.Marker({ position: latlng });
  marker.setMap(map);
  searchMarkers.push(marker);
  return marker;
}

/* -------------------------
   Kakao Services
-------------------------- */
function coordToAddress(latlng) {
  return new Promise((resolve) => {
    if (!geocoder) return resolve({ road: "", jibun: "" });

    geocoder.coord2Address(latlng.getLng(), latlng.getLat(), (res, status) => {
      if (status !== kakao.maps.services.Status.OK || !res || !res[0]) {
        return resolve({ road: "", jibun: "" });
      }
      const road = res[0]?.road_address?.address_name || "";
      const jibun = res[0]?.address?.address_name || "";
      resolve({ road, jibun });
    });
  });
}

/* -------------------------
   Add favorite from latlng
   ✅ 이름 입력 팝업 복구!
-------------------------- */
async function addFavoriteAtLatLng(latlng) {
  if (!latlng) return;

  const inputName = prompt("이름을 입력해주세요", "즐겨찾기");
  if (inputName === null) return; // 취소
  const name = inputName.trim() || "즐겨찾기";

  const { road, jibun } = await coordToAddress(latlng);

  const id = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  const fav = {
    id,
    name,
    lat: latlng.getLat(),
    lng: latlng.getLng(),
    roadAddress: road,
    jibunAddress: jibun,
    createdAt: Date.now(),
  };

  favorites.unshift(fav);
  saveFavorites();
  syncFavoriteMarkers();
  await renderFavorites();

  map.panTo(latlng);
  updateTopCardsByLatLng(fav.lat, fav.lng).catch(() => {});
}

/* -------------------------
   Context menu
-------------------------- */
function showContextMenuAtClient(clientX, clientY, latlng) {
  if (!dom.ctxMenu) return;

  lastRightClickLatLng = latlng || lastRightClickLatLng;

  const pad = 6;
  const maxX = window.innerWidth - 220;
  const maxY = window.innerHeight - 90;

  const x = Math.min(Math.max(pad, clientX + pad), maxX);
  const y = Math.min(Math.max(pad, clientY + pad), maxY);

  dom.ctxMenu.style.left = `${x}px`;
  dom.ctxMenu.style.top = `${y}px`;
  dom.ctxMenu.style.display = "block";
}

function hideContextMenu() {
  if (!dom.ctxMenu) return;
  dom.ctxMenu.style.display = "none";
}

/* -------------------------
   Route picking & drawing
-------------------------- */
function setPickingMode(mode) {
  pickingMode = mode;
  if (dom.pickStartBtn) dom.pickStartBtn.style.outline = mode === "start" ? "2px solid #23c26b" : "";
  if (dom.pickEndBtn) dom.pickEndBtn.style.outline = mode === "end" ? "2px solid #23c26b" : "";
}

function resetRoute() {
  pickingMode = null;
  startLatLng = null;
  endLatLng = null;

  if (startMarker) startMarker.setMap(null);
  if (endMarker) endMarker.setMap(null);
  startMarker = null;
  endMarker = null;

  if (polyline) polyline.setMap(null);
  polyline = null;

  if (dom.routeStartInput) dom.routeStartInput.value = "";
  if (dom.routeEndInput) dom.routeEndInput.value = "";
  if (dom.routeInfo) dom.routeInfo.textContent = "";

  setPickingMode(null);
}

function updateRouteInputLabels() {
  if (dom.routeStartInput && startLatLng)
    dom.routeStartInput.value = `${startLatLng.getLat().toFixed(6)}, ${startLatLng.getLng().toFixed(6)}`;
  if (dom.routeEndInput && endLatLng)
    dom.routeEndInput.value = `${endLatLng.getLat().toFixed(6)}, ${endLatLng.getLng().toFixed(6)}`;
}

function handleMapClickForRoute(mouseEvent) {
  if (!pickingMode) return;

  const fixed = getFixedLatLng(mouseEvent) || mouseEvent.latLng;
  if (!fixed) return;

  if (pickingMode === "start") {
    startLatLng = fixed;
    if (startMarker) startMarker.setMap(null);
    startMarker = new kakao.maps.Marker({ position: fixed });
    startMarker.setMap(map);
  } else if (pickingMode === "end") {
    endLatLng = fixed;
    if (endMarker) endMarker.setMap(null);
    endMarker = new kakao.maps.Marker({ position: fixed });
    endMarker.setMap(map);
  }

  updateRouteInputLabels();
  setPickingMode(null);
}

function drawRouteLine() {
  if (!startLatLng || !endLatLng) {
    if (dom.routeInfo) dom.routeInfo.textContent = "출발/도착을 먼저 지정해줘!";
    return;
  }
  if (polyline) polyline.setMap(null);

  polyline = new kakao.maps.Polyline({
    path: [startLatLng, endLatLng],
    strokeWeight: 6,
    strokeColor: "#23c26b",
    strokeOpacity: 0.9,
    strokeStyle: "solid",
  });
  polyline.setMap(map);

  if (dom.routeInfo) dom.routeInfo.textContent = "경로(직선) 표시 완료!";
}

/* -------------------------
   Tabs
-------------------------- */
function setTab(which) {
  if (!dom.tabSearch || !dom.tabRoute || !dom.paneSearch || !dom.paneRoute) return;

  if (which === "search") {
    dom.tabSearch.classList.add("active");
    dom.tabRoute.classList.remove("active");
    dom.paneSearch.classList.remove("hidden");
    dom.paneRoute.classList.add("hidden");
  } else {
    dom.tabRoute.classList.add("active");
    dom.tabSearch.classList.remove("active");
    dom.paneRoute.classList.remove("hidden");
    dom.paneSearch.classList.add("hidden");
  }
}

/* -------------------------
   Search
-------------------------- */
function doPlaceSearch(query) {
  if (!places || !map) return;
  const q = (query || "").trim();
  if (!q) return;

  clearSearchMarkers();

  places.keywordSearch(q, (res, status) => {
    if (status !== kakao.maps.services.Status.OK || !Array.isArray(res) || res.length === 0) return;

    const bounds = new kakao.maps.LatLngBounds();
    res.slice(0, 10).forEach((p) => {
      const latlng = new kakao.maps.LatLng(Number(p.y), Number(p.x));
      const m = addSearchMarker(latlng);
      bounds.extend(latlng);

      kakao.maps.event.addListener(m, "click", () => {
        map.panTo(latlng);
        updateTopCardsByLatLng(latlng.getLat(), latlng.getLng()).catch(() => {});
      });
    });

    map.setBounds(bounds);
  });
}

/* -------------------------
   Init Kakao Map
-------------------------- */
function initKakaoMap() {
  if (!dom.mapEl) return;

  const center = new kakao.maps.LatLng(37.5665, 126.9780);
  map = new kakao.maps.Map(dom.mapEl, { center, level: 7 });

  geocoder = new kakao.maps.services.Geocoder();
  places = new kakao.maps.services.Places();

  // ✅ Kakao rightclick
  kakao.maps.event.addListener(map, "rightclick", (mouseEvent) => {
    ignoreDomContextUntil = Date.now() + 150;

    const latlng = getFixedLatLng(mouseEvent) || mouseEvent.latLng;

    // 1) domEvent 있으면 그대로
    if (mouseEvent.domEvent) {
      try {
        mouseEvent.domEvent.preventDefault();
        mouseEvent.domEvent.stopPropagation();
      } catch {}
      showContextMenuAtClient(mouseEvent.domEvent.clientX, mouseEvent.domEvent.clientY, latlng);
      return;
    }

    // 2) domEvent 없으면 point -> client 변환 (✅ #map 실제 scale 기준)
    if (mouseEvent.point) {
      const { sx, sy, rect } = getMapElementScale();
      if (rect) {
        const clientX = rect.left + mouseEvent.point.x * sx;
        const clientY = rect.top + mouseEvent.point.y * sy;
        showContextMenuAtClient(clientX, clientY, latlng);
        return;
      }
    }

    // 3) fallback
    const { rect } = getMapElementScale();
    if (rect) showContextMenuAtClient(rect.left + rect.width / 2, rect.top + rect.height / 2, latlng);
  });

  // ✅ DOM contextmenu (백업)
  dom.mapEl.addEventListener(
    "contextmenu",
    (e) => {
      if (Date.now() < ignoreDomContextUntil) return;
      e.preventDefault();
      e.stopPropagation();
      const latlng = clientToLatLng(e.clientX, e.clientY);
      showContextMenuAtClient(e.clientX, e.clientY, latlng);
    },
    { passive: false }
  );

  // 클릭: 메뉴 닫기 + route picking
  kakao.maps.event.addListener(map, "click", (mouseEvent) => {
    hideContextMenu();
    handleMapClickForRoute(mouseEvent);
  });

  // 메뉴 외 클릭 시 닫기
  document.addEventListener("mousedown", (e) => {
    if (e.button === 2) return;
    if (!dom.ctxMenu) return;
    if (dom.ctxMenu.contains(e.target)) return;
    hideContextMenu();
  });

  // ESC 닫기
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") hideContextMenu();
  });

  syncFavoriteMarkers();
  renderFavorites().catch(() => {});
  updateTopCardsByLatLng(center.getLat(), center.getLng()).catch(() => {});
}

/* -------------------------
   DOM Bind
-------------------------- */
function bindDom() {
  dom.canvas = document.querySelector(".page-canvas");
  dom.mapEl = document.getElementById("map");

  ensureContextMenuDom();

  dom.searchInput = document.getElementById("search-input");
  dom.searchBtn = document.getElementById("search-btn");

  dom.tabSearch = document.getElementById("tab-search");
  dom.tabRoute = document.getElementById("tab-route");
  dom.paneSearch = document.getElementById("pane-search");
  dom.paneRoute = document.getElementById("pane-route");

  dom.routeStartInput = document.getElementById("route-start");
  dom.routeEndInput = document.getElementById("route-end");
  dom.pickStartBtn = document.getElementById("route-pick-start");
  dom.pickEndBtn = document.getElementById("route-pick-end");
  dom.routeBtn = document.getElementById("route-btn");
  dom.routeResetBtn = document.getElementById("route-reset-btn");
  dom.routeInfo = document.getElementById("route-info");

  dom.weatherIcon = document.getElementById("weather-icon") || document.querySelector(".weather-card .ui-icon");
  dom.umbrellaIcon = document.getElementById("umbrella-icon") || document.querySelector(".umbrella-card .ui-icon");

  dom.favoriteList = document.getElementById("favorite-list");

  if (dom.ctxAddFavBtn) {
    dom.ctxAddFavBtn.addEventListener("click", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      hideContextMenu();
      await addFavoriteAtLatLng(lastRightClickLatLng);
    });
  }

  if (dom.searchBtn && dom.searchInput) {
    dom.searchBtn.addEventListener("click", () => doPlaceSearch(dom.searchInput.value));
    dom.searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") doPlaceSearch(dom.searchInput.value);
    });
  }

  if (dom.tabSearch) dom.tabSearch.addEventListener("click", () => setTab("search"));
  if (dom.tabRoute) dom.tabRoute.addEventListener("click", () => setTab("route"));

  if (dom.pickStartBtn) dom.pickStartBtn.addEventListener("click", () => setPickingMode("start"));
  if (dom.pickEndBtn) dom.pickEndBtn.addEventListener("click", () => setPickingMode("end"));
  if (dom.routeBtn) dom.routeBtn.addEventListener("click", () => drawRouteLine());
  if (dom.routeResetBtn) dom.routeResetBtn.addEventListener("click", () => resetRoute());
}

/* -------------------------
   Boot
-------------------------- */
function boot() {
  updateCanvasScale();

  window.addEventListener("resize", () => {
    updateCanvasScale();
    if (map) setTimeout(() => map.relayout(), 0);
  });

  bindDom();
  loadFavorites();

  if (window.kakao && kakao.maps) {
    if (kakao.maps.load) {
      kakao.maps.load(() => initKakaoMap());
    } else {
      initKakaoMap();
    }
  } else {
    console.error("Kakao Maps SDK가 로드되지 않았어요. index.html의 kakao script를 확인해줘!");
  }
}

document.addEventListener("DOMContentLoaded", boot);
